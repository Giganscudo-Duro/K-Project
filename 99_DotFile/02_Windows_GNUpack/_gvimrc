" [GNUpack デフォルト設定] =============================================
" {{{

" don't use viminfo file"
set viminfo=

" don't use swap file"
set noswapfile

" don't use backup file"
set nobackup

" enable highlight"
syntax on

" setting IME behavior"
set iminsert=0 imsearch=0
inoremap <silent> <ESC> <ESC>

" setting Font"
set guifont=Migu_1M:h11

" }}}


" [基本設定] ===========================================================
" {{{

" 参考１：options - Vim 日本語ドキュメント
" https://vim-jp.org/vimdoc-ja/options.html

" カレントディレクトリを変更
" set F:\01-Vim

" 印刷時のフォントを設定
" set printfont=ゆたぽん（コーディング）:h12:cSHIFTJIS

" ヤンク値をクリップボードにセット
set clipboard=unnamed

" 文字エンコーディング
set encoding=utf-8
set fileencodings=iso-2022-jp,iso-2022-jp-2,utf-8,euc-jp,sjis

" vim利用中に保持したレジスタやら何やらをviminfoに保存する。
" 一応こんなのを設定できるらしい
" - コマンドライン履歴と検索履歴
" - レジスタ
" - マーク
" - バッファリスト
" - グローバル変数
" ただし、面倒なので何も指定しない
set viminfo=

" }}}


" [GUI Options] ========================================================
" {{{

" 詳細はヘルプで確認
" :h guioptions
" 基本的に、オプション追加は「set guioptions+=XXX」
" 基本的に、オプション削除は「set guioptions-=XXX」

" gVimでのメニューバーを非表示にする
set guioptions-=m

" gVimでのツールバーを非表示にする
set guioptions-=T

" gVimでの左右のスクロールバーを非表示にする
" set guioptions-=r " 右スクロールバーを非表示に
" set guioptions-=l " 左スクロールバーを非表示に
" set guioptions-=R " 垂直分割されたウィンドウがあるときの右スクロールバーを非表示に
" set guioptions-=L " 垂直分割されたウィンドウがあるときの左スクロールバーを非表示に

" gVimでの水平スクロールバーを非表示にする
" set guioptions-=b

" 全角空白をハイライトする
" カラースキームよりも前に宣言しないと、Linux版だとエラーをおこす。
" https://oki2a24.com/2019/02/22/attention-when-visualizing-double-byte-space-with-vim-and-error-when-failing/
" ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
" VimEnter Autocommands for "*" の処理中にエラーが検出されました:
" E28: そのような名のハイライトグループはありません: IdeographicSpace
" 続けるにはENTERを押すかコマンドを入力してください
" ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
augroup highlightIdegraphicSpace
    autocmd!
    autocmd Colorscheme * highlight IdeographicSpace term=underline ctermbg=DarkGreen guibg=DarkGreen
    autocmd VimEnter,WinEnter * match IdeographicSpace /　/
augroup END

" カラースキームの設定(gVim用)
colorscheme darkblue

" カーソルを点滅させない
set guicursor=a:blinkon0

" }}}


" [タブ関係の挙動設定]=================================================
"{{{

" タブ関係の独自関数設定はここを参考：http://thinca.hatenablog.com/entry/20111204/1322932585

" タブページを常に表示
set showtabline=2

" gVimでもテキストベースのタブ管理を行う
set guioptions-=e

"}}}


" [gVim用 ステータスライン] ===========================================
"{{{

" ファイル名表示
set statusline=%t

" 変更チェック表示
set statusline+=%m

" 読み込み専用かどうかを表示
set statusline+=%r

" ヘルプページならば[HELP]と表示
set statusline+=%h

" プレビューウィンドウならば[Preview]と表示
set statusline+=%w

" これ以降は右詰
set statusline+=%=

" 意味なし
set statusline+=

" 半角スペース
set statusline+=\ 

" ファイルのエンコード
set statusline+=[ENC=%{&fileencoding}]

" " カーソルのある場所までの文字数をカウント
" " wordcount.vim を導入済みの場合のみ有効にすること
" set statusline+=[Count=%{WordCount()}]
" set updatetime=500

" 現在行数/全行数
set statusline+=[%l/%L]

" ステータスラインを常に表示（０：表示しない、１：2つ以上ウィンドウがある時だけ表示）
set laststatus=2

"}}}


" [キーマッピング]=====================================================
"{{{


"}}}


" <C-K> エスケープから実行できるオリジナルショートカット
" {{{

" # で始まっている目次をリストアップする
nnoremap <C-K>toc :vimgrep "^# " %<CR>

" 画面を問答無用でリフレッシュする
map <C-K>init :enew!<CR>

"フォント設定画面を開く
map <C-K>font :set guifont=*<CR>

" }}}


" 自作関数
" {{{

"【URLをFireFoxで開く】
""{{{
function! KanaBrowserFF()
    echo "Call KanaBrowserFF"
    set shell=cmd.exe

    " 利用するブラウザのパスを指定。'"PATH"'であること。「\」は「\\」でエスケープすること
    let s:browser = '"C:\Program Files (x86)\Mozilla Firefox\firefox.exe"'
    " URLパターン(^\を区切りとして追加)
    "   通常のURL     https\=:\/\/[^ >,;:]*   http:// もしくは https:// で始ま
    "   ニコニコ動画  sm[0-9]\+               sm で始まり、半角数字が１回以上繰り返される
    let s:link = matchstr(getline("."), 'https\=:\/\/[^ >,;:]*\|sm[0-9]\+')
    if match(s:link, "^http")==0
        echo "Pattern:[http]"
        call vimproc#popen2(s:browser . " " . s:link)
    elseif match(s:link, "^sm")==0
        echo "Pattern:[niconico]"
        let s:link = "http://www.nicovideo.jp/watch/" . s:link
        call vimproc#popen2(s:browser . " " . s:link)
    else
        echo "No URI found in line"
    endif
    set shell=vimrun.exe
    unlet s:link
endfunction
"}}}
" ==== 上記関数の呼び出し
map <C-K>ff :call KanaBrowserFF()<CR>


"【URLをIEで開く】
""{{{
function! KanaBrowserIE()
    echo "Call KanaBrowserIE"
    "====準備部分
    " 外部コマンド実行時のシェルを強制的に変更する。
    set shell=cmd.exe
    " 利用するブラウザのパスを '"XXXX"' という形式で指定する
    let s:browser = '"C:\\Program Files (x86)\\Internet Explorer\\iexplore.exe"'
    " カーソルラインの文字列から取得する URLパターンを指定する。(複数指定する場合は ^\ で区切って指定する)
    "   通常のURL     https\=:\/\/[^ >,;:]*   http:// もしくは https:// で始ま
    "   ニコニコ動画  sm[0-9]\+               sm で始まり、半角数字が１回以上繰り返される
    let s:link = matchstr(getline("."), 'https\=:\/\/[^ >,;:]*\|sm[0-9]\+')
    " 取得したURLパターンから、実際にブラウザに渡すURLを生成する（ｓｍXXXXXとかだけ）
    if match(s:link, "^http")==0
        echo "Pattern:[http]"
        call vimproc#popen2(s:browser . " " . s:link)
    elseif match(s:link, "^sm")==0
        echo "Pattern:[niconico]"
        let s:link = "http://www.nicovideo.jp/watch/" . s:link
        call vimproc#popen2(s:browser . " " . s:link)
    else
        echo "No URI found in line"
    endif
    set shell=vimrun.exe
    unlet s:link
endfunction
"}}}
" ==== 上記関数の呼び出し
map <C-K>ie :call KanaBrowserIE()<CR>


"【規定のプログラムでファイルを開く】
"{{{
function! KanaOpenFile()
    echo "Call Kana-OpenFile-Ver3"
    set shell=cmd.exe
    " netrw 画面である回安価を判断する
    let s:flag = stridx(getline(2), '" Netrw Directory Listing      ')
    if s:flag == -1
        if match(s:tmp, "^D:")==0
            echo 'Open FilePath'
            let s:file = substitute(s:tmp, "\\", "/", "g")
            call vimproc#popen2("start" . " " . "" . " " . s:file)
            unlet s:flag
            unlet s:tmp
            unlet s:file
        else
            echo "No FilePath found in line..."
        endif
    else
        echo 'Open NetrwPath'
        let s:name = getline(".")
        let s:dir = substitute(getline(3), '"   ', "", "g")
        let s:tmp = s:dir . '/' . s:name
        let s:file = substitute(s:tmp, "\\", "/", "g")
        call vimproc#popen2("start" . " " . "" . " " . s:file)
        unlet s:name
        unlet s:dir
        unlet s:flag
        unlet s:tmp
        unlet s:file
    endif
    set shell=vimrun.exe
endfunction
" }}}
" ==== 上記関数の呼び出し
map <C-K>op :call KanaOpenFile()<CR>


"【ゆたぽんフォントで印刷する】
"{{{
function! KanaYutaponPrint()
    echo "Call KanaYutaponPrint"
    set printfont=ゆたぽん（コーディング）:h12:cSHIFTJIS
    hardcopy
    set printfont=Migu_1M:h12:cSHIFTJIS
endfunction
"}}}
" ==== 上記関数の呼び出し
map <C-K>print :call KanaYutaponPrint()<CR>


"【ヤンクしている文字列をテキストを読み上げる】
"{{{
" function! KanaReadByVoiceloid_Ver1()
"     " echo "Call KanaReadByVoiceloid"
"     set shell=cmd.exe
"
"     " 文字列を Voiceroid に中継するアプリ
"     let s:application = '"D:\\ProgramFiles\\tamiyasu_talk\\vrx.exe"'
"
"     " ヤンクしている内容を格納
"     let s:base_string = @@
"
"     " 改行コードを\nに置き換える
"     " let strings2 = substitute(strings1, "
", "\n", "g")
"     " echo "strings2 = ". strings2
"
"     " 文字列をシェルコマンドとして使えるようエスケープ処理
"     let s:escaped_string = shellescape(s:base_string)
"
"     " 実行アプリのパスと、読み上げさせたい文字列を連結
"     call vimproc#popen2(s:application . " " . s:escaped_string)
"
"     set shell=vimrun.exe
" endfunction
" }}}
" ==== 上記関数の呼び出し
" map <C-K>read :call KanaReadByVoiceloid_Ver1()<CR>


"【ビジュアルモードで選択した範囲のテキストを読み上げる】
"{{{
" なぜか、vrx.exe に渡される文字列の順序がおかしくなる場合がある。
" vimproc#popen2 での非同期処理の呼び出し順序がおかしくなってる？
function! KanaReadByVoiceloid_Ver2()
    " echo "Call KanaReadByVoiceloid"
    set shell=cmd.exe

    " 文字列を Voiceroid に中継するアプリ
    let s:application = '"D:\\ProgramFiles\\tamiyasu_talk\\vrx.exe"'

    " ビジュアルモードでの選択範囲をヤンク
    y
    " ヤンクした内容を格納
    let s:base_string = @@
    " echo s:base_string
    " 改行コードを\nに置き換える
    " let strings2 = substitute(strings1, "
", "\n", "g")
    " echo "strings2 = ". strings2

    " 文字列をシェルコマンドとして使えるようエスケープ処理
    let s:escaped_string = shellescape(s:base_string)
    " echo s:escaped_string

    " 実行アプリのパスと、読み上げさせたい文字列を連結
    call vimproc#popen3(s:application . " " . s:escaped_string)

    set shell=vimrun.exe
endfunction
" " }}}
" " ==== 上記関数の呼び出し
map <C-K>read :call KanaReadByVoiceloid_Ver2()<CR>


" }}}



